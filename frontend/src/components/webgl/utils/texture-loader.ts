/**
 * Texture Loader Utilities for Pactwise WebGL Landing Page
 *
 * Loads and manages textures generated by scripts/generate-textures.ts
 */

import * as THREE from 'three';

/**
 * Texture metadata interface
 */
interface TextureMetadata {
  width: number;
  height: number;
  channels: number;
  format: 'Luminance' | 'RGB';
}

/**
 * Load raw texture from .bin file with metadata
 */
export async function loadRawTexture(
  name: string
): Promise<THREE.DataTexture> {
  const basePath = '/textures';

  // Load metadata
  const metadataResponse = await fetch(`${basePath}/${name}.json`);
  const metadata: TextureMetadata = await metadataResponse.json();

  // Load buffer
  const bufferResponse = await fetch(`${basePath}/${name}.bin`);
  const arrayBuffer = await bufferResponse.arrayBuffer();
  const data = new Uint8Array(arrayBuffer);

  // Determine format (RedFormat is the modern replacement for LuminanceFormat)
  const format = metadata.format === 'RGB' ? THREE.RGBFormat : THREE.RedFormat;

  // Create DataTexture
  const texture = new THREE.DataTexture(
    data,
    metadata.width,
    metadata.height,
    format,
    THREE.UnsignedByteType
  );

  texture.needsUpdate = true;
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;

  return texture;
}

/**
 * Load Bayer matrix texture for dithering
 */
export async function loadBayerMatrix(): Promise<THREE.DataTexture> {
  const texture = await loadRawTexture('bayer-matrix-8x8');
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.minFilter = THREE.NearestFilter;
  texture.magFilter = THREE.NearestFilter;
  return texture;
}

/**
 * Load purple/pink gradient LUT for color grading
 */
export async function loadGradientLUT(): Promise<THREE.DataTexture> {
  return loadRawTexture('gradient-lut-purple-pink');
}

/**
 * Load noise texture for various effects
 */
export async function loadNoiseTexture(): Promise<THREE.DataTexture> {
  const texture = await loadRawTexture('noise-tile');
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  return texture;
}

/**
 * Texture cache to avoid re-loading
 */
const textureCache = new Map<string, THREE.DataTexture>();

/**
 * Load texture with caching
 */
export async function loadTextureCached(
  name: string
): Promise<THREE.DataTexture> {
  if (textureCache.has(name)) {
    return textureCache.get(name)!;
  }

  const texture = await loadRawTexture(name);
  textureCache.set(name, texture);
  return texture;
}

/**
 * Preload all essential textures
 */
export async function preloadTextures(): Promise<{
  bayerMatrix: THREE.DataTexture;
  gradientLUT: THREE.DataTexture;
  noise: THREE.DataTexture;
}> {
  const [bayerMatrix, gradientLUT, noise] = await Promise.all([
    loadBayerMatrix(),
    loadGradientLUT(),
    loadNoiseTexture(),
  ]);

  return {
    bayerMatrix,
    gradientLUT,
    noise,
  };
}

/**
 * Clear texture cache
 */
export function clearTextureCache(): void {
  textureCache.forEach((texture) => texture.dispose());
  textureCache.clear();
}
